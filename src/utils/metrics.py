import torch as t
from torch import Tensor
import einops
from jaxtyping import Float

device = t.device("cuda" if t.cuda.is_available() else "cpu")

def calc_kl_penalty(
    logits: Float[Tensor, "minibatch_size seq_len d_vocab"],
    ref_logits: Float[Tensor, "minibatch_size seq_len d_vocab"],
    kl_coef: float,
    prefix_len: int,
) -> Float[Tensor, ""]:
    '''
    Computes the KL divergence between the logits and the reference logits, scaled
    by the penalty function. This is used to stop the learned policy from diverging
    too much from the original reference model's policy.

    logits:
        The logits of the generated samples (under the new model).
    ref_logits:
        The logits of the generated samples (under the reference model).
    kl_coef:
        The coefficient of the KL penalty.
    prefix_len:
        The length of the prefix to ignore when computing the KL divergence.
    '''
    log_p = t.log_softmax(logits[:, prefix_len-1:-1, :], dim=-1)
    log_ref_q = t.log_softmax(ref_logits[:, prefix_len-1:-1, :], dim=-1)
    unsummed_kl = t.exp(log_p) * (log_p - log_ref_q)
    summed_kl = einops.reduce(unsummed_kl, 'mb seq d_vocab -> mb seq', 'sum')
    return summed_kl.mean() * kl_coef


def calc_entropy_bonus(
    logits: Float[Tensor, "minibatch_size seq_len d_vocab"],
    ent_coef: float,
    prefix_len: int
) -> Float[Tensor, ""]:
    '''
    Return the entropy bonus term, suitable for gradient ascent.

    logits:
        the logits of the tokens generated by the model.
    ent_coef:
        the coefficient for the entropy loss, which weights its contribution to the overall objective function.
    prefix_len:
        The length of the prefix to ignore when computing the KL divergence.
    '''
    log_p = t.log_softmax(logits[:, prefix_len-1:-1, :], dim=-1)
    unsummed_ent = t.exp(log_p) * log_p
    summed_ent = einops.reduce(unsummed_ent, 'mb seq d_vocab -> mb seq', 'sum')
    return -summed_ent.mean() * ent_coef


def calc_value_function_loss(
    values: Float[Tensor, "minibatch_size gen_len"],
    mb_returns: Float[Tensor, "minibatch_size gen_len"],
    vf_coef: float
) -> Float[Tensor, ""]:
    '''Compute the value function portion of the loss function.

    values:
        the value function predictions for the sampled minibatch (using the updated critic network)
    mb_returns:
        the target for our updated critic network (computed as `advantages + values` from the old network)
    vf_coef:
        the coefficient for the value loss, which weights its contribution to the overall loss. Denoted by c_1 in the paper.
    '''
    assert values.shape == mb_returns.shape,\
        f"Shape mismatch: {values.shape=}, {mb_returns.shape=}. Did you slice 'values' tokens correctly?"
    return vf_coef * (values - mb_returns).pow(2).mean()


def calc_clipped_surrogate_objective(
    logprobs: Float[Tensor, "minibatch_size gen_len"],
    mb_logprobs: Float[Tensor, "minibatch_size gen_len"],
    mb_advantages: Float[Tensor, "minibatch_size gen_len"],
    clip_coef: float,
    eps: float = 1e-8,
) -> Float[Tensor, ""]:
    '''Return the clipped surrogate objective, suitable for maximisation with gradient ascent.

    logprobs:
        the logprobs of the action taken by the agent, according to the new policy
    mb_logprobs:
        logprobs of the actions taken in the sampled minibatch (according to the old policy)
    mb_advantages:
        advantages calculated from the sampled minibatch
    clip_coef:
        amount of clipping, denoted by epsilon in Eq 7.
    eps:
        used to add to std dev of mb_advantages when normalizing (to avoid dividing by zero)
    '''
    assert logprobs.shape == mb_logprobs.shape == mb_advantages.shape,\
        f"Shape mismatch: {logprobs.shape=}, {mb_logprobs.shape=}, {mb_advantages.shape=}. Did you create logprobs using 'get_logprobs' correctly?"
    logits_diff = logprobs - mb_logprobs
    
    # [batch, gen_len]
    r_theta = t.exp(logits_diff)

    # [batch, gen_len]
    mb_advantages = (mb_advantages - mb_advantages.mean()) / (mb_advantages.std() + eps)

    non_clipped = r_theta * mb_advantages
    clipped = t.clip(r_theta, 1-clip_coef, 1+clip_coef) * mb_advantages
    return t.minimum(non_clipped, clipped).mean()


def calc_greedy_clipped_surrogate_objective(
    logprobs: Float[Tensor, "minibatch_size gen_len"],
    mb_logprobs: Float[Tensor, "minibatch_size gen_len"],
    mb_advantages: Float[Tensor, "minibatch_size gen_len"],
    mb_greedy_advantages: Float[Tensor, "minibatch_size gen_len"],
    clip_coef: float,
    eps: float = 1e-8,
) -> Float[Tensor, ""]:
    '''Return the clipped surrogate objective, suitable for maximisation with gradient ascent.

    logprobs:
        the logprobs of the action taken by the agent, according to the new policy
    mb_logprobs:
        logprobs of the actions taken in the sampled minibatch (according to the old policy)
    mb_advantages:
        advantages calculated from the sampled minibatch
    mb_greedy_advantages:
        greedy advantages calculated from the sampled minibatch
    clip_coef:
        amount of clipping, denoted by epsilon in Eq 7.
    eps:
        used to add to std dev of mb_advantages when normalizing (to avoid dividing by zero)
    '''
    assert logprobs.shape == mb_logprobs.shape == mb_advantages.shape,\
        f"Shape mismatch: {logprobs.shape=}, {mb_logprobs.shape=}, {mb_advantages.shape=}. Did you create logprobs using 'get_logprobs' correctly?"
    logits_diff = logprobs - mb_logprobs
    
    # [batch, gen_len]
    r_theta = t.exp(logits_diff)

    # [batch, gen_len]
    mb_greedy_advantages = (mb_greedy_advantages - mb_advantages.mean()) / (mb_advantages.std() + eps)

    non_clipped = r_theta * mb_greedy_advantages
    clipped = t.clip(r_theta, 1-clip_coef, 1+clip_coef) * mb_greedy_advantages
    return t.minimum(non_clipped, clipped).mean()
